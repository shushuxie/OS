#### 并发

并发的概念
  : 并发是指单个处理器，多道程序运行，程序分别占用时间片，这些程序关系就是并发；

并行的概念
    : 并行是多个处理器，分别处理不同的程序，程序在同一实际同时运行；

二者区别

  * 处理器数量；一个指单个，一个指多个
  * 运行时间，并发是指程序开始到结束期间时间有重叠，但是程序不同时运行，并行是同时运行； 


#### 多线程

> 好吧，事实证明，存在某些类型
的程序，我们称之为多线程（multi-threaded）应用程序。每个线程（thread）都像在这个程
序中运行的独立代理程序，代表程序做事。但是这些线程访问内存，对于它们来说，每个
内存节点就像一个桃子。如果我们不协调线程之间的内存访问，程序将无法按预期工作。

> 为单个运行进程提供的新抽象：线程（thread）。经典观点是一个程序只有
一个执行点（一个程序计数器，用来存放要执行的指令），但多线程（multi-threaded）程序
会有多个执行点（`多个程序计数器，每个都用于取指令和执行`）。换一个角度来看，每个线
程类似于独立的进程，只有一点区别：`它们共享地址空间，从而能够访问相同的数据。`

#### 进程和线程区别

> 线程有一个程序计数器（PC），记录程序
从哪里获取指令。每个线程有自己的一组用于计算的寄存器。所以，如果有两个线程运行
在一个处理器上，从运行一个线程（T1）切换到另一个线程（T2）时，必定发生上下文切
换（context switch）。线程之间的上下文切换类似于进程间的上下文切换。对于进程，我们
将状态保存到进程控制块（Process Control Block，PCB）。现在，我们需要一个或多个线程
控制块（Thread Control Block，TCB），保存每个线程的状态。但是，与进程相比，线程之
间的上下文切换有一点主要区别：地址空间保持不变（即不需要切换当前使用的页表）。

> 在多线程的进程中，每个线程独立运行，当然可以调用各种例程来完成正在执
行的任何工作。不是地址空间中只有一个栈，而是每个线程都有一个栈

![image](https://github.com/shushuxie/OS/assets/54092341/c6fb1e06-f8a6-4c87-ac0c-a51908618322)

> 进程控制块(PCB, Process Control Block)是操作系统用来管理进程运行的数据结构。每个进程都在操作系统中有一个对应的PCB，因此PCB是进程存在的唯一标志。

当进程创建时，生成PCB。进程终止时，操作系统会回收它的PCB。PCB的主要内容如下：

调度和状态信息：调度进程和处理机使用情况
进程间通信信息：进程间通信相关的各种标识
存储管理信息：指向进程映像存储空间数据结构
进程所用资源：进程使用的系统资源，如打开文件等
有关数据结构连接信息：与PCB相关的进程队列

线程是进程的一部分，描述指令流执行状态，它是进程中指令执行流的最小单元，是CPU调度的基本单位。
进程是资源分配维度的概念：由一组相关资源构成，包括地址空间（代码段、数据段）、打开的文件等各种资源。
线程是处理机调度维度的概念：描述在进程资源环境中的指令流执行状态。

cpu调度以线程为单位进行分配，pid1-Thread1，pid1-Thread2，pid2-threa1；

```
PCB含有三大类信息： 
（1） 进程标识，哪个程序在执行，执行了几次（本进程的标识），产生者标识（父进程标识），用户标识 
（2） 处理机状态信息保存区，主要就是寄存器，保存进程的运行现场信息：

用户可见寄存器，程序使用的数据，地址
控制和状态寄存器，程序计数器pc，程序状态字PSW
栈指针，过程调用/系统调用/中断处理和返回时需要用到
（3） 进程控制信息

调度和状态信息，用于操作系统调度进程并占用处理机使用。运行状态？等待？进程当前的执行现状
进程间通信信息，各种标识、信号、信件等
进程本身的存储管理信息，即指向本进程映像存储空间的数据结构，内存信息，占了多少？要不要回收？
进程所用资源，打开使用的系统资源，如文件
有关数据结构连接信息，父进程，子进程，构成一个链，进程可以连接到一个进程队列，或链接到其他进程的PCB
```

#### 共享数据,调度不可控

```c
#include <stdio.h>
#include <assert.h>
 #include <pthread.h>
#include <unistd.h>

void *mythread(void *arg) {
     printf("%s\n", (char *) arg);
     return NULL;
     }

 int
 main(int argc, char *argv[]) {
    pthread_t p1, p2;
    int rc;
    printf("main: begin\n");
    rc = pthread_create(&p1, NULL, mythread, "A"); assert(rc == 0);
    rc = pthread_create(&p2, NULL, mythread, "B"); assert(rc == 0);
    // join waits for the threads to finish
    // join 方法保证主线程运行到这里会等待子线程运行结束，不然子线程
    // 还没运行整个进程就结束了，或者让主线程睡眠一会，给子线程运行时间；
//    rc = pthread_join(p1, NULL); assert(rc == 0);
//    rc = pthread_join(p2, NULL); assert(rc == 0);
    sleep(1);
    printf("main: end\n");
    return 0;
    }
```

```
#include <stdio.h>
#include <pthread.h>

static volatile int counter = 0;

//
// mythread()
//
 // Simply adds 1 to counter repeatedly, in a loop
 // No, this is not how you would add 10,000,000 to
 // a counter, but it shows the problem nicely.
 //
 void *
 mythread(void *arg)
 {
 printf("%s: begin\n", (char *) arg);
 int i;
 for (i = 0; i < 1e7; i++) {
 counter = counter + 1;
 }
 printf("%s: done\n", (char *) arg);
 return NULL;
 }

 //
 // main()
 //
 // Just launches two threads (pthread_create)
 // and then waits for them (pthread_join)
 //
 int
 main(int argc, char *argv[])
 {
 pthread_t p1, p2;
 printf("main: begin (counter = %d)\n", counter);
 pthread_create(&p1, NULL, mythread, "A");
 pthread_create(&p2, NULL, mythread, "B");

 // join waits for the threads to finish
 pthread_join(p1, NULL);
 pthread_join(p2, NULL);
 printf("main: done with both (counter = %d)\n", counter);
 return 0;
 }
=============================================================
D:\clion\OS\cmake-build-debug\OS.exe
main: begin (counter = 0)
A: begin
B: begin
A: done
B: done
main: done with both (counter = 14030237)
```

![image](https://github.com/shushuxie/OS/assets/54092341/efe5a3bd-314f-43be-817f-f928d869ff04)

发生问题原因就是两个线程抢占同一个变量，线程1执行过程如果没有把更改后的值存回到响应地址空间，线程2取值仍是另原来的值，线程2完成了增加，线程1
拿到了时间片只是根据TCB内容重置了地址空间值，导致数据错误；我们更加希望`原子性`的操作，没有中间过程；

> 补充：关键并发术语
临界区、竞态条件、不确定性、互斥执行
这 4 个术语对于并发代码来说非常重要，我们认为有必要明确地指出。 请参阅 Dijkstra 的一些早期
著作[D65，D68]了解更多细节。
 临界区（critical section）是访问共享资源的一段代码，资源通常是一个变量或数据结构。
 竞态条件（race condition）出现在多个执行线程大致同时进入临界区时，它们都试图更新共享
的数据结构，导致了令人惊讶的（也许是不希望的）结果。
 不确定性（indeterminate）程序由一个或多个竞态条件组成，程序的输出因运行而异，具体取
决于哪些线程在何时运行。这导致结果不是确定的（deterministic），而我们通常期望计算机系统给出确
定的结果。
 为了避免这些问题，线程应该使用某种互斥（mutual exclusion）原语。这样做可以保证只有一
个线程进入临界区，从而避免出现竞态，并产生确定的程序输出。
