### 一、虚拟化概念

以最基本的计算机资源 CPU 为例，
假设一个计算机只有一个 CPU（尽管现代计算机一般拥有 2 个、4 个或者更多 CPU），虚拟
化要做的就是将这个 CPU 虚拟成多个虚拟 CPU 并分给每一个进程使用，因此，每个应用都
以为自己在独占 CPU，但实际上只有一个 CPU。这样操作系统就创造了美丽的假象——它
虚拟化了 CPU。

### 二、进程
    系统提供的基本的抽象—— 进程。进程的非正式定义非常简单：进程就
    是运行中的程序。程序本身是没有生命周期的，它只是存在磁盘上面的一些指令（也可能
    是一些静态数据）。是操作系统让这些字节运行起来，让程序发挥作用。

#### 时分共享，空分共享
   * 时分共享（time sharing）就是分享时间片；计算机的CPU，网络等资源逐个分配给程序，然后分配给别的程序；
   * 空分共享 ：空间共享，例如：磁盘空间分配给某个用户，只要这个文件没有被清理，就没法分配给别的人，但整个磁盘可以分配给不同用户；

#### 进程的机器状态（machine state）

   * 内存，运行的指令存在于内存中,数据的读写也在内存中，进程可以访问的内存空间称为--地址空间
   * 寄存器 ：标识一下状态，指令寄存器，栈寄存器
   * I/O设备 ：文件列表等等；

#### 进程细节

1. 进程API
* 创建（create）：操作系统必须包含一些创建新进程的方法。在 shell 中键入命令
  或双击应用程序图标时，会调用操作系统来创建新进程，运行指定的程序。
* 销毁（destroy）：由于存在创建进程的接口，因此系统还提供了一个强制销毁进
  程的接口。当然，很多进程会在运行完成后自行退出。但是，如果它们不退出，
  用户可能希望终止它们，因此停止失控进程的接口非常有用。
* 等待（wait）：有时等待进程停止运行是有用的，因此经常提供某种等待接口。
* 其他控制（miscellaneous control）：除了杀死或等待进程外，有时还可能有其他
  控制。例如，大多数操作系统提供某种方法来暂停进程（停止运行一段时间），
  然后恢复（继续运行).
  *状态（statu）：通常也有一些接口可以获得有关进程的状态信息，例如运行了多
  长时间，或者处于什么状态。

2. 进程创建
   程序先从磁盘中，加载到内存（可以懒加载，需要再加载），为程序运行栈分配内存，可能分配堆内存
   为每个进程打开三个标准文件描述符，标准输入，输出和错误；
3. 状态
  * 运行：程序正在处理器上运行，执行相应的指令
  * 就绪：程序准备好运行，但是由于某些原因没有运行
  * 阻塞：程序某种操作等待其他操作结束，例如 I/O操作；

#### 进程的api操作

​	

```c
1. 可以使用man命令查看一些函数细节；例如：man fork 可以看fork函数的操作；阅读文档j可以往下翻页 q是退出文档。

2. fork（void）函数；
  #include <unistd.h>
	创建一个新的子进程，不需要参数;
	返回值：子进程中返回0，父进程中返回子进程的process id；
	注意点：新创建的子进程会在fork函数调用的下一行开始执行，掠过fork之前的代码，会有自己的地址空间？？？
	父进程和子进程的代码执行顺序无法确定，除非父进程调用wait函数，子进程结束后执行父进程wait后面的代码；
	
3. wait()
       #include <sys/types.h>
       #include <sys/wait.h>
       pid_t wait(int *wstatus);
       pid_t waitpid(pid_t pid, int *wstatus, int options);
       作用：挂起调用api的线程，直到该线程的子线程结束；
       返回值：wait函数 成功子线程的pid，失败返回-1
       wstatus 是线程执行状态，在外面定义可以接受出来；传入NULL是不需要接收；

4. exec()函数，是一个家族，但是没有exec，
 			#include <unistd.h>
			int execvp(const char *file, char *const argv[]);
			作用：执行别的文件中的程序
			参数： 第一个参数是执行文件的名称（可执行文件），后面是文件需要的参数，参数最后以NULL结尾；
			返回值：-1 失败
			
			函数分两组
			execl()、execle()、execlp()、
			execv()、execvp()和 execvP()
			带“l”的是指参数以list，单个写入
			带“V”的是参数以数组写入
			带“p“指的是不需要path，第一个参数执行的文件名；
			带”e“指的是environments，环境，有第三种类型的参数--环境变量；
			 
	   int execl(const char *pathname, const char *arg, .../* (char  *) NULL */);
       int execlp(const char *file, const char *arg, ... /* (char  *) NULL */);
       int execle(const char *pathname, const char *arg, .../*, (char *) NULL,  *const envp[] */);
       
       int execv(const char *pathname, char *const argv[]);
       int execvp(const char *file, char *const argv[]);
       int execvpe(const char *file, char *const argv[], char *const envp[]);
```



#### 机制：受限直接执行

虚拟化机制的两个问题：

​		1：程序运行的更快;肯定越快越好，最快的就是直接运行程序，独享CPU；

​		2：操作系统要能接收到控制权，为了实现桃子分配给多个人；但是CPU每次只能让一个
程序使用，如果程序在运行那么就操作系统就没法运行，操作系统不运行如何切换另一个程序运行呢？

操作系统直接执行的过程：操作系统只能等程序return的时候接手控制权

![直接运行](OS-homework\image\img.png)

受限直接运行：某些操作不允许进程去做，例如IO；只有调用系统接口，让系统去执行；系统执行是内核模式，普通用户是用户模式；一次IO就会从用户模式--》内核模式--》用户模式；

`两种模式的区别是执行指令的等级，一些特殊指令只能内核模式执行`

![受限执行](OS-homework\image\img_1.png)

进程间的切换：切换是控制权的争夺，两种方式

* 协同方式：等待程序调用系统，转移控制权；没有主动性，

* 非协作方式：操作系统自己控制 -- 时钟中断系统，定期把控制权转移到操作系统；

  

  切换进程就是伴随着上下文切换，就是保存执行的状态方便恢复之后继续执行；

  ![](OS-homework\image\img_2.png)

#### 进程调度



