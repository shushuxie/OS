#### 抽象地址空间

虚拟地址的一大作用就是让进程觉得自己独占了整个磁盘空间，其实仅仅是系统让你看到的假象。

早期的进程是单个的占用整个空间，后面改为了多个，可以运行多任务，就需要实现内存的保护，隔离；

##### 为什么要有虚拟内存

​	还是为了方便使用，如果只运行一个程序那么不需要；如果内存加载一个程序，然后放回磁盘加载另一个也可以，但是太慢了；保证多个用户，多个程序运行，又不互相影响，只能统一管理内存；

#### 插叙：内存操作API

```c
申请内存和释放操作
    malloc
    free()
    realloc()
    
    gdb，valgrind
    调试工具和valgrind内存检测工具；
```

#### 机制：地址转换

> 我们利用了一种通用技术，有时被称为`基于硬件`的地址转换（hardware-based address translation），简称为地址转换（address translation）。它可以看成是受限直接执行这种一般方 法的补充。利用地址转换，硬件对`每次内存访问进行处理`（即指令获取、数据读取或写 入），将指令中的虚拟（virtual）地址转换为数据实际存储的物理（physical）地址。因此， 在`每次内存引用时，硬件都会进行地址转换`，将应用程序的内存引用重定位到内存中实际 的位置。

> 仅仅依靠硬件不足以实现虚拟内存，因为它只是提供了底层机制来提高效率。 操作系统必须在关键的位置介入，设置好硬件，以便完成正确的地址转换。

> 所有这些工作都是为了创造一种美丽的假象：每个程序都拥有私有的内存，那 里存放着它自己的代码和数据。虚拟现实的背后是丑陋的物理事实：`许多程序其实是在同 一时间共享着内存`，就像 CPU（或多个 CPU）在不同的程序间切换运行。



##### 动态重定位

每个 CPU 需要两个硬件寄存器：基址（base）寄存器和界限（bound）寄存 器，有时称为限制（limit）寄存器。这组基址和界限寄存器，让我们能够将地址空间放在物 理内存的任何位置，同时又能确保进程只能访问自己的地址空间

`physical address = virtual address + base`



base提供了偏移量，bound用来检查内存安全

context switch的时候也会进行这种切换



硬件支持

* 模式内核，用户转换
* MMU处理地址计算
