#### 抽象地址空间

虚拟地址的一大作用就是让进程觉得自己独占了整个磁盘空间，其实仅仅是系统让你看到的假象。

早期的进程是单个的占用整个空间，后面改为了多个，可以运行多任务，就需要实现内存的保护，隔离；

##### 为什么要有虚拟内存

​	还是为了方便使用，如果只运行一个程序那么不需要；如果内存加载一个程序，然后放回磁盘加载另一个也可以，但是太慢了；保证多个用户，多个程序运行，又不互相影响，只能统一管理内存；

#### 插叙：内存操作API

```c
申请内存和释放操作
    malloc
    free()
    realloc()
    
    gdb，valgrind
    调试工具和valgrind内存检测工具；
```

#### 机制：地址转换

> 我们利用了一种通用技术，有时被称为`基于硬件`的地址转换（hardware-based address translation），简称为地址转换（address translation）。它可以看成是受限直接执行这种一般方 法的补充。利用地址转换，硬件对`每次内存访问进行处理`（即指令获取、数据读取或写 入），将指令中的虚拟（virtual）地址转换为数据实际存储的物理（physical）地址。因此， 在`每次内存引用时，硬件都会进行地址转换`，将应用程序的内存引用重定位到内存中实际 的位置。

> 仅仅依靠硬件不足以实现虚拟内存，因为它只是提供了底层机制来提高效率。 操作系统必须在关键的位置介入，设置好硬件，以便完成正确的地址转换。

> 所有这些工作都是为了创造一种美丽的假象：每个程序都拥有私有的内存，那 里存放着它自己的代码和数据。虚拟现实的背后是丑陋的物理事实：`许多程序其实是在同 一时间共享着内存`，就像 CPU（或多个 CPU）在不同的程序间切换运行。



##### 动态重定位

每个 CPU 需要两个硬件寄存器：基址（base）寄存器和界限（bound）寄存 器，有时称为限制（limit）寄存器。这组基址和界限寄存器，让我们能够将地址空间放在物 理内存的任何位置，同时又能确保进程只能访问自己的地址空间

`physical address = virtual address + base`



base提供了偏移量，bound用来检查内存安全

context switch的时候也会进行这种切换



硬件支持

* 模式内核，用户转换
* MMU处理地址计算

#### 内存分段

##### 为什么要分段

更好的利用内存，减少内部碎片浪费；分段之后可以分开存储每个段

##### 确定地址段的方式

1. 使用标识符

![img](https://cdn.nlark.com/yuque/0/2023/png/38602243/1692233132590-8c642289-bca0-4cec-ab8a-283fbd7a9b72.png)

1. 产生地址的方式



硬件还有其他方法来决定特定地址在哪个段。在隐式（implicit）方式中，硬件通过地 址产生的方式来确定段。例如，如果地址由程序计数器产生（即它是指令获取），那么地址 在代码段。如果基于栈或基址指针，它一定在栈段。其他地址则在堆段。



##### 支持共享

分段之后可以，让一些特定的段共享，例如代码段，但是必须要有硬件的支持，把响应的段标记为只读，进行保护才行；



##### 总结

 分段解决了一些问题，帮助我们实现了更高效的虚拟内存。不只是动态重定位，通过 避免地址空间的逻辑段之间的大量潜在的内存浪费，分段能更好地支持稀疏地址空间。它 还很快，因为分段要求的算法很容易，很适合硬件完成，地址转换的开销极小。分段还有 一个附加的好处：代码共享。如果代码放在独立的段中，这样的段就可能被多个运行的程 序共享。 但我们已经知道，在内存中分配不同大小的段会导致一些问题，我们希望克服。首先， 是我们上面讨论的外部碎片。由于段的大小不同，空闲内存被割裂成各种奇怪的大小，因 此满足内存分配请求可能会很难。用  



#### 空闲地址空间管理



##### 底层机制

* 分割与合并 	申请空间会分割给你，free会把相邻空闲空间进行合并
* ![image.png](https://cdn.nlark.com/yuque/0/2023/png/38602243/1692282694380-dd4e8f2a-1a1a-40c1-a833-5c22db6e2908.png)

* malloc分配空间，不是单纯的空间，还会分配一部分给一个头部，用来记录一些信息

  空间大小，magic用来安全性校验

  ##### 空间分配机制

  * 最优匹配  最优匹配（best fit）策略非常简单：首先遍历整个空闲列表，找到和请求大小一样或更 大的空闲块，然后返回这组候选者中最小的一块。这就是所谓的最优匹配（也可以称为最 小匹配）。只需要遍历一次空闲列表，就足以找到正确的块并返回。 最优匹配背后的想法很简单：选择最接它用户请求大小的块，从而尽量避免空间浪费。 然而，这有代价。简单的实现在遍历查找正确的空闲块时，要付出较高的性能代价。
  *  最差匹配  最差匹配（worst fit）方法与最优匹配相反，它尝试找最大的空闲块，分割并满足用户 需求后，将剩余的块（很大）加入空闲列表。最差匹配尝试在空闲列表中保留较大的块， 而不是向最优匹配那样可能剩下很多难以利用的小块。但是，最差匹配同样需要遍历整个 空闲列表。更糟糕的是，大多数研究表明它的表现非常差，导致过量的碎片，同时还有很 高的开销。 
  * 首次匹配  首次匹配（first fit）策略就是找到第一个足够大的块，将请求的空间返回给用户。同样， 剩余的空闲空间留给后续请求。 首次匹配有速度优势（不需要遍历所有空闲块），但有时会让空闲列表开头的部分有很 多小块。因此，分配程序如何管理空闲列表的顺序就变得很重要。一种方式是基于地址排 序（address-based ordering）。通过保持空闲块按内存地址有序，合并操作会很容易，从而减 少了内存碎片。
  *  下次匹配  不同于首次匹配每次都从列表的开始查找，下次匹配（next fit）算法多维护一个指针， 指向上一次查找结束的位置。其想法是将对空闲空间的查找操作扩散到整个列表中去，避 免对列表开头频繁的分割。这种策略的性能与首次匹配很接它，同样避免了遍历查找。

#### 分页：介绍 

##### 为什么要分页

​	内存如果没有分段会产生内部碎片，分段会产生过多的外部碎片，减少外部碎片就是分配统一的内存大小给不同的进程；也就是分页技术；

![image-20230819104541558](/Users/xieshuqiang/Documents/typora/操作系统导论/OS-homework/image/img_4.png)

![标识符](OS-homework/image/Snipaste_2023-08-19_10-48-45.png)

![](OS-homework/image/Snipaste_2023-08-19_10-51-09.png)



##### 页表

为了记录地址空间的每个虚拟页放在物理内存中的位置，操作系统通常为每个进程保 存一个数据结构，称为页表（page table）。页表的主要作用是为地址空间的每个虚拟页面保 存地址转换（address translation），从而让我们知道每个页在物理内存中的位置。***每个进程都存有一份页表***

上述例子中：pa=128 因此 需要6位来表示 2^6 = 128 



```
地址转换例子
1. 图1 VA有64个字节，真实物理地址PA 128个字节；VA分为了4部分，16大小为一页，对应PA的4个page；
2. 图二  因为进程的虚拟地址空间是 64 字节，我们的虚拟地址总共需要 6 位（2^6 = 64）
        2^6 = 64 总字节
        2^4 = 16 每页的大小
        2^2 = 4 页数；
        这是对应的关系，信息的总量就是64 无论是单个字节看待，还是先找页，再找页内的偏移量需要的信息位相同
        例如： 8 字节每页，那么就会有 8 页 每个需要 2^3 = 8 还是6位数据即可；
        因此该例子中把前两位划分为页的信息位即可；
3. 图三： VA 01 = 1 是第一页，通过虚拟页号，我们现在可以检索页表，找到虚拟页 1 所在的物理页面。在上面的页表中物				 理帧号（PFN）（有时也称为物理页号，physical page number 或 PPN）是 7（二进制 111）。
					 二进制：1110101 = 117 刚好是物理页的第七页，偏移量也是对应的；
```

##### 页表存在哪里

内存之中，没法存储在处理器里面，因为太大了；

>  我们没有在 MMU 中利用任何特 殊的片上硬件，来存储当前正在运行的进程的页表，而是 将每个进程的页表存储在内存中。现在让我们假设页表存 在于操作系统管理的物理内存中，稍后我们会看到，很多 操作系统内存本身都可以虚拟化，因此页表可以存储在操 作系统的虚拟内存中（甚至可以交换到磁盘上）

```
页表可以有多大 Byte --> KB --> MB -->GB
32位的系统 虚拟地址分成 20 位的 VPN 和 12 位的偏移量
总内存 = 2^32 = 4,294,967,296 = 4*1024*1024*1024
加入页大小为 4KB 是12位保存的信息量；
可以分页数为 1024*1024 = 1048576 如果每个页数需要4个字节记录（4*8=32） 
存储页信息需要 4MB；
如果系统有100个进程，就需要400MB来存储；
```

##### 页表列表中有什么

![Snipaste_2023-08-19_12-10-24](/Users/xieshuqiang/Documents/typora/操作系统导论/OS-homework/image/Snipaste_2023-08-19_12-10-24.png)



包含两部分内容

* PFN 物理页地址
* 标志位  描述该页的一些关键信息，读取权限等
  * 有效位（valid bit） 通常用于指示特定地址转换是否有效。通过简单地将地址空间中所有未使用的页面标记为无效，我 们不再需要为这些页面分配物理帧，从而节省大量内存。 
  * 保护位（protection bit），表明页是否可以读取、写入或执行。同样，以这 些位不允许的方式访问页，会陷入操作系统。 还有其他一些重要的部分，但现在我们不会过多讨论。存在位（present bit）表示该页 是在物理存储器还是在磁盘上（即它已被换出，swapped out）。
  * 脏位（dirty bit） 也很常见，表明页面被带入内存后是否被修改过。
  *  参考位（reference bit，也被称为访问位，accessed bit）有时用于追踪页是否被访问，也 用于确定哪些页很受欢迎，因此应该保留在内存中。这些知识在页面替换（page replacement） 时非常重要，我们将在随后的章节中详细研究这一主题。
